
<!DOCTYPE html>
<html>
  <head>
    <title>Tokenizer</title>
  </head>
  <body>
  <script>

  var Tokenizer = function(str) {
    // Private
    var lexemes = str.split(/[" "]/);
    var index = 0;

    // Public
    var peek = function() {
      if (index >= lexemes.length) return { type: "EOF", val: "" };

      var lexeme = lexemes[index];
      var c = lexeme.charAt(0);

      if      (c == '&') token = { type: "AND"   , val: "&"    } ;
      else if (c == '|') token = { type: "OR"    , val: "|"    } ;
      else if (c == '(') token = { type: "OPEN"  , val: "("    } ;
      else if (c == ')') token = { type: "CLOSE" , val: ")"    } ;
      else               token = { type: "STR"   , val: lexeme } ;

      return token;
    }

    var get = function() {
      token = peek();
      if (token.type != "EOF") index++;

      return token;
    }

    getStr = function() { return str; }

    return {
      peek   : peek,
      get    : get,
      getStr : getStr
    }
  }

  function dump(tokenizer) {
    for(token = tokenizer.get(); token.type != "EOF"; token = tokenizer.get()) {
      console.log("type: ", token.type, " value: ", token.val);
    }
  }

  var Token = function(type, val) {
    return {
      type    : type,
      val     : val,
      toString: function() { return "type: " + this.type + " val: " + this.val; }
    };

    return token;
  }

  function getc() {
    if (index < str.length) {
      var c = str.charAt(index);

      index++;

      return c;
    }

    return false;
  }

  function ungetc() {
    index--;
  }

  function get() {
    var c, token, val;

    function isOp(c)   { return c.match(/[ &|()]/); }
    function isText(c) { return !isOp(c);           }

    if (!(val = c = getc())) {
      token = new Token("EOF", "EOF");
    } else if (isText(c)) {
      while((c = getc()) && isText(c)) {
        val += c;
      }
      token = new Token("STR", val);
    } else if (c == " ") {
      c = getc();
      if (!c) {
        token = new Token("EOF", "EOF");
      } else if (isOp(c)) {
        token = new Token(c, c);
        while((c = getc()) && isOp(c));
      } else {
        token = new Token("&", "&");
      }
    } else if (isOp(c)) {
        token = new Token(c, c);
        while((c = getc()) && isOp(c));
    } else {
      console.log("BUG: Unknown case");
      token = new Token("EOF", "EOF");
    }

    if (c) ungetc();

    return token;
  }

  str = "(this&that|another)"
  index = 0;

  for(token = get(); token.type != "EOF"; token = get()) {
    console.log("get: " + token);
  }

//  token = get();
//  console.log("get: " + token);
//
//  token = get();
//  console.log("get: " + token);
//
//  token = get();
//  console.log("get: " + token);
//
//  token = get();
//  console.log("get: " + token);

//  function testToken(lexeme) {
//    token = new Token(lexeme);
//    console.log("token: " + token);
//  }

//  testToken("&");
//  testToken("|");
//  testToken(")");
//  testToken("coriolanus");

//  function testGetchar(str) {
//    var c;
//
//    console.log(str);
//
//    while((c = getchar())) {
//      console.log("index: " + index + " char: [" + c + "]");
//    }
//  }

//  testGetchar("this is a long string & |");

//  var shakespeare = new Tokenizer("to be or & not to | be");
//  var auden       = new Tokenizer("perfection of & a kind was | what he was after");
//
//  dump(shakespeare);
//  console.log("================");
//  dump(auden);


  </script>
  </body>
</html>
